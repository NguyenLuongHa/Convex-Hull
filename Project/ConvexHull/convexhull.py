# -*- coding: utf-8 -*-
"""convexHull.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q9_sULdNuS1RrNraaAkjTY3-vOXKViog
"""

import matplotlib
import matplotlib.pyplot as plt
import random
import time
import numpy as np
import math

class Point:
    def __init__(self, x, y) -> None:
       self.x = x
       self.y = y
    
    def display(self):
        print("("+str(self.x)+" ,"+str(self.y)+" )")

    def duplicate(self, A):
        if self.x == A.x and self.y == A.y:
          return True
        else:
          return False

# Check the intersecting
"""
def checkIntersect(A: Point, B: Point, C: Point, D: Point):  # ~13, segment vs segment

    # in case: xA = xB or xC = xD
    if A.x == B.x:
        if C.x == D.x:
            return False
        else:
            A2 = (C.y - D.y)/(C.x - D.x)
            b2 = (C.y-C.x*A2)
            yIntersection = A.x*A2 + b2
            if max(A.y, B.y) > yIntersection and min(A.y, B.y) < yIntersection:
                return True
            else:
                return False
    if C.x == D.x:
        A1 = (A.y - B.y)/(A.x - B.x)
        b1 = (A.y-A.x*A1)
        yIntersection = A.x*A1 + b1
        if max(C.y, D.y) > yIntersection and min(C.y, D.y) < yIntersection:
            return True
        else:
            return False

    # Range of value x of intersection
    max1 = max(A.x, B.x)  # maxX AB
    min2 = min(C.x, D.x)  # minX CD
    if max1 < min2:
        return False

    min1 = min(A.x, B.x)  # minX AB
    max2 = max(C.x, D.x)  # maxX CD
    if max2 < min1:
        return False

    minRange = max(min1, min2)
    maxRange = min(max1, max2)

    # find intersection

    A1 = (A.y - B.y)/(A.x - B.x)
    A2 = (C.y - D.y)/(C.x - D.x)
    if A1 == A2:
        return False
    # x = (b2 - b1)/(a1 - a2)
    xIntersection = ((C.y-C.x*A2)-(A.y-A.x*A1))/(A1 - A2)

    if xIntersection > minRange and xIntersection < maxRange:
        return True
    else:
        return False
"""

def checkIntersect(A, B, C, D):  # ~6, segment vs straight

    # in case: xA = xB or xC = xD
    if A.x == B.x:
        if C.x == D.x:
            return False
        else:
            A2 = (C.y - D.y)/(C.x - D.x)
            b2 = (C.y-C.x*A2)
            yIntersection = A.x*A2 + b2
            if max(A.y, B.y) > yIntersection and min(A.y, B.y) < yIntersection:
                return True
            else:
                return False
    if C.x == D.x:
        if A.x < C.x:
            if B.x > C.x:
                return True
            else:
                return False
        else:
            if B.x > C.x:
                return False
            else:
                return True

    # Range of value x of intersection
    if A.x > B.x:
        minRange = B.x
        maxRange = A.x
    else:
        minRange = A.x
        maxRange = B.x

    # find intersection

    A1 = (A.y - B.y)/(A.x - B.x)
    A2 = (C.y - D.y)/(C.x - D.x)
    if A1 == A2:
        return False
    # x = (b2 - b1)/(a1 - a2)
    xIntersection = ((C.y-C.x*A2)-(A.y-A.x*A1))/(A1 - A2)

    if xIntersection > minRange and xIntersection < maxRange:
        return True
    else:
        return False

def minMax2(points: list):
    # ~ 3n
    minX = points[0].x
    maxX = points[0].x
    minY = points[0].y
    maxY = points[0].y
    min_x = 0
    max_x = 0
    min_y = 0
    max_y = 0
    # min X, max X
    for i in range(1, len(points)):
      if minX > points[i].x:
        minX = points[i].x
        min_x = i
      elif maxX < points[i].x:
        maxX = points[i].x
        max_x = i
      if minY > points[i].y:
        min_y = i
        minY = points[i].y
      elif maxY < points[i].y:
        maxY = points[i].y
        max_y = i
    return min_x, max_x, min_y, max_y

"""
# check
C = Point(-4, -3)
D = Point(3, 4)
A = Point(-3, -7)
B = Point(6,-3)
points = [A, B, C, D]
print(minMax2(points))
"""

def reduceData(points: list):  # ~ 19n
    minx, maxx, miny, maxy = minMax2(points)     # ~3n
    top = points[maxy]
    bot = points[miny]
    left = points[minx]
    right = points[maxx]
    partI = list()  # data between right and top
    partII = list()  # data between top and left
    partIII = list()  # data between left and bot
    partIV = list()  # data between right and bot
    center = Point((top.y+bot.y)/2, (left.x+right.x)/2)
    for i in points:
        cur = i
        if cur.x > top.x:
            if cur.y > right.y:
                if checkIntersect(cur, center, top, right):
                    partI.append(cur)
                    continue
        else:
            if cur.y > left.y:
                if checkIntersect(cur, center, top, left):
                    partII.append(cur)
                    continue                          # ~8
        if cur.x > bot.x:
            if cur.y < right.y:
                if checkIntersect(cur, center, bot, right):
                    partIV.append(cur)
                    continue
        else:
            if cur.y < left.y:
                if checkIntersect(cur, center, bot, left):
                    partIII.append(cur)
                    continue                           # ~8
    partI.append(top)
    partII.append(left)
    partIII.append(bot)
    partIV.append(right)
    return right, top, left, bot, partI, partII, partIII, partIV

def convexHull(right, top, left, bot, partI: list, partII: list, partIII: list, partIV: list):  #  3 n *(len(path)+1)
    center = Point((top.y+bot.y)/2, (left.x+right.x)/2)
    path = list()
    path. append(right)
    cur: Point = right
    next = partI[0]
    if next.duplicate(top):
      path.append(top)
    while not next.duplicate(top):
        next = top
        for i in partI:
            if checkIntersect(center, i, next, cur):
                next = i
        path.append(next)
        poplist = list()
        for i in range(len(partI)-1):
          if not checkIntersect( partI[i], center, next, top):
            poplist.append(i)
        poplist.reverse()
        for i in poplist:
          partI.pop(i)
        cur = next

    next = partII[0]
    if next.duplicate(left):
      path.append(left)
    while not next.duplicate(left):
        next = left
        for i in partII:
            if checkIntersect(center, i, next, cur):
                next = i
        path.append(next)
        poplist = list()
        for i in range(len(partII)-1):
          if not checkIntersect( partII[i], center, next, left):
            poplist.append(i)
        poplist.reverse()
        for i in poplist:
          partII.pop(i)
        cur = next

    next = partIII[0]
    if next.duplicate(bot):
      path.append(bot)
    while not next.duplicate(bot):
        next = bot
        for i in partIII:
            if checkIntersect(center, i, next, cur):
                next = i
        path.append(next)
        poplist = list()
        for i in range(len(partIII)-1):
          if not checkIntersect( partIII[i], center, next, bot):
            poplist.append(i)
        poplist.reverse()
        for i in poplist:
          partIII.pop(i)
        cur = next

    next = partIV[0]
    if next.duplicate(right):
      path.append(right)
    while not next.duplicate(right):
        next = right
        for i in partIV:
            if checkIntersect(center, i, next, cur):
                next = i
        path.append(next)
        poplist = list()
        for i in range(len(partIV)-1):
          if not checkIntersect( partIV[i], center, next, right):
            poplist.append(i)
        poplist.reverse()
        for i in poplist:
          partIV.pop(i)
        cur = next

    return path

points = list()
for i in range(1000):
  points.append(Point(random.randint(-10000,10000),random.randint(-10000,10000)))

right, top, left, bot, partI, partII, partIII, partIV = reduceData(points)
print((len(partI)+len(partII)+len(partIII)+len(partIV)))
center = Point((top.y+bot.y)/2, (left.x+right.x)/2)
plt.figure()
for i in points:
  plt.plot(i.x, i.y, 'ro')
x = [right.x, top.x, left.x, bot.x, right.x]
y = [right.y, top.y, left.y, bot.y, right.y]
plt.plot(x,y)
xp = list()
yp = list()
for i in partI:
  xp.append(i.x)
  yp.append(i.y)
plt.plot(xp ,yp ,'bo')
plt.plot(center.x, center.y, 'bo')

path = convexHull(right, top, left, bot, partI, partII, partIII, partIV)
xpath = list()
ypath = list()
for i in path:
  xpath.append(i.x)
  ypath.append(i.y)
plt.plot(xpath ,ypath ,'g--')
plt.show()
print(len(path))

start_time = time.time()
right, top, left, bot, partI, partII, partIII, partIV = reduceData(points)
path = convexHull(right, top, left, bot, partI, partII, partIII, partIV)
end_time1 = time.time()
print(end_time1 - start_time)

"""#check
C = Point(4, -3)
D = Point(3, 4)
A = Point(-3, -7)
B = Point(6,-3)
plt.figure()
x = [A.x, B.x]
y = [A.y, B.y]
plt.plot(x, y)
x = [C.x, D.x]
y = [C.y, D.y]
plt.plot(x, y)
plt.show()

if checkIntersect(A, B, C, D):
  print("True")
else: 
  print("False")

#check percent of data reduced ~ 1/2
points = list()
percents = list()
for i in range(100):
  for i in range(1000):
    points.append(Point(random.uniform(1,100), random.uniform(1,100)))
  r, t, l, b, p1, p2, p3, p4 = reduceData(points)
  percent = (len(p1)+len(p2)+len(p3)+len(p4))
  print(percent)
  points.clear()
  percents.append(percent)
print("mean:" + str(np.array(percents).mean()))

def minMax(points: list):
    # ~ 3n
    minX = points[0].x
    maxX = points[0].x
    minY = points[0].x
    maxY = points[0].x
    min_x = 0
    max_x = 0
    min_y = 0
    max_y = 0
    # min X, max X
    for i in range(1, int((len(points)-1)/2)):
        if points[2*i-1].x > points[2*i].x:
            if minX > points[2*i].x:
                minX = points[2*i].x
                min_x = 2*i
            if maxX < points[2*i-1].x:
                maxX = points[2*i-1].x
                max_x = 2*i-1
        else:
            if minX > points[2*i-1].x:
                minX = points[2*i-1].x
                min_x = 2*i-1
            if maxX < points[2*i].x:
                maxX = points[2*i].x
                max_x = 2*i
    print(min_x, max_x)
    if points[len(points)-1].x > points[max_x].x:
      max_x = len(points)-1
    elif points[len(points)-1].x < points[min_x].x:
      min_x = len(points)-1

    # min Y, max Y
    for i in range(1, int((len(points)-1)/2)):
        if points[2*i-1].y > points[2*i].y:
            if minY > points[2*i].y:
                minY = points[2*i].y
                min_y = 2*i
            if maxY < points[2*i-1].y:
                maxY = points[2*i-1].y
                max_y = 2*i-1
        else:
            if minY > points[2*i-1].y:
                minY = points[2*i-1].y
                min_y = 2*i-1
            if maxY < points[2*i].y:
                maxY = points[2*i].y
                max_y = 2*i
    print(min_y, max_y)
    if points[len(points)-1].y > points[max_y].y:
      max_y = len(points)-1
    elif points[len(points)-1].y < points[min_y].y:
      min_y = len(points)-1
    return min_x, max_x, min_y, max_y

# check
C = Point(4, -3)
D = Point(3, 4)
A = Point(-3, -7)
B = Point(6,-3)
points = [A, B, C, D]
print(minMax(points))
"""